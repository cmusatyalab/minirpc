/*
 * miniRPC - TCP RPC library with asynchronous operations and TLS support
 *
 * Copyright (C) 2007-2008 Carnegie Mellon University
 *
 * This software is distributed under the terms of the Eclipse Public License,
 * Version 1.0 which can be found in the file named LICENSE.  ANY USE,
 * REPRODUCTION OR DISTRIBUTION OF THIS SOFTWARE CONSTITUTES RECIPIENT'S
 * ACCEPTANCE OF THIS AGREEMENT
 */

#include <pthread.h>
#include <assert.h>
#include <poll.h>
#include <errno.h>
#define MINIRPC_POLLSET
#define MINIRPC_INTERNAL
#include "internal.h"
#include "pollset_impl.h"

struct poll_table {
	struct poll_fd **pfd;
	struct pollfd *ev;
	int idx;
	int count;
};

static int poll_create_set(struct pollset *pset)
{
	return 0;
}

static void poll_destroy_set(struct pollset *pset)
{
	return;
}

static int poll_add(struct pollset *pset, struct poll_fd *pfd)
{
	pollset_wake(pset);
	return 0;
}

static int poll_modify(struct pollset *pset, struct poll_fd *pfd)
{
	pollset_wake(pset);
	return 0;
}

static void poll_remove(struct pollset *pset, struct poll_fd *pfd)
{
	return;
}

static void poll_build_table(gpointer key, gpointer value, gpointer data)
{
	struct poll_table *pt=data;
	struct poll_fd *pfd=value;
	struct pollfd *ev;

	assert(pt->idx < pt->count);
	pt->pfd[pt->idx]=pfd;
	ev=&pt->ev[pt->idx++];
	ev->fd=pfd->fd;
	if (pfd->flags & POLLSET_READABLE)
		ev->events |= POLLIN;
	if (pfd->flags & POLLSET_WRITABLE)
		ev->events |= POLLOUT;
	/* POLLERR and POLLHUP are implicitly set */
}

static int poll_poll(struct pollset *pset)
{
	struct poll_table pt;
	struct poll_fd *pfd;
	struct pollfd *ev;
	int i;

	pthread_mutex_lock(&pset->lock);
	pt.idx=0;
	pt.count=g_hash_table_size(pset->members);
	pt.pfd=g_new0(struct poll_fd *, pt.count);
	pt.ev=g_new0(struct pollfd, pt.count);
	g_hash_table_foreach(pset->members, poll_build_table, &pt);
	pthread_mutex_unlock(&pset->lock);

	if (poll(pt.ev, pt.count, -1) == -1) {
		g_free(pt.ev);
		g_free(pt.pfd);
		return errno;
	}

	for (i=0; i<pt.count; i++) {
		pfd=pt.pfd[i];
		ev=&pt.ev[i];
		if ((ev->revents & POLLOUT) && pfd->writable_fn &&
					(pfd->flags & POLLSET_WRITABLE) &&
					!pfd->dead)
			pfd->writable_fn(pfd->private, pfd->fd);
		if ((ev->revents & POLLIN) && pfd->readable_fn &&
					(pfd->flags & POLLSET_READABLE) &&
					!pfd->dead)
			pfd->readable_fn(pfd->private, pfd->fd);
		if ((ev->revents & (POLLERR|POLLHUP)) && !pfd->dead) {
			if ((ev->revents & POLLHUP) && pfd->hangup_fn)
				pfd->hangup_fn(pfd->private, pfd->fd);
			else if (pfd->error_fn)
				pfd->error_fn(pfd->private, pfd->fd);
			pollset_del(pset, pfd->fd);
		}
	}
	g_free(pt.ev);
	g_free(pt.pfd);
	return 0;
}

static const struct pollset_ops ops = {
	.create = poll_create_set,
	.destroy = poll_destroy_set,
	.add = poll_add,
	.modify = poll_modify,
	.remove = poll_remove,
	.poll = poll_poll
};
const struct pollset_ops *ops_poll = &ops;
