#!/usr/bin/perl

our $cflags = "-Werror -fskeletons-copy -funnamed-unions -fnative-types " .
			"-fcompound-names";

use strict;
use warnings;
use IO::Handle;
use File::Copy;
use File::Compare;

our $tmp1 = "tmp1.$$";
our $tmp2 = "tmp2.$$";

END {
	my $status = $?;
	unlink($tmp1, $tmp2);
	$? = $status;
}

# Move $src to $dest, adding an "AUTOGENERATED FILE" warning on top.
sub move_add_warning {
	my $src = shift;
	my $dest = shift;
	
	open(RD, "<", $src) || die "Can't read $src";
	open(WR, ">", $dest) || die "Can't write $dest";
	print WR "/* AUTOGENERATED FILE -- DO NOT EDIT */\n";
	WR->flush();
	copy(\*RD, \*WR) || die "Can't write $dest";
	close RD;
	close WR;
	unlink($src);
}

# Move $src to $dest, unless the contents of $src and $dest are identical,
# in which case delete $src.
sub cond_move {
	my $src = shift;
	my $dest = shift;
	
	if (compare($src, $dest)) {
		rename($src, $dest);
	} else {
		unlink($src);
	}
}

# Move files from the current directory to the named subdir.  Add an
# "AUTOGENERATED FILE" comment header to each one.  Don't replace the existing
# file if it's identical to the new file.  Generate a makefile fragment listing
# all of the files.
sub populate_subdir {
	my $dirname = shift;
	my $varname = shift;
	my $files = shift;
	
	my $assign = " =";
	my $file;
	
	open(FH, ">", $tmp1) || die "Couldn't open $tmp1";
	print FH "# AUTOGENERATED FILE -- DO NOT EDIT\n";
	foreach $file (@$files) {
		next unless -f $file;
		move_add_warning($file, $tmp2);
		cond_move($tmp2, "$dirname/$file");
		print FH "$varname $assign $file\n";
		$assign = "+=";
	}
	close FH;
	cond_move($tmp1, "$dirname/$dirname.mk");
}

# For each C, header, or object file in the given directory: if the basename
# of the file (without the extension) is equal to a basename in the provided
# list of files, leave the file alone.  Otherwise, print a message and delete
# it.  (This prevents sources and objects for obsolete classes from
# accumulating in the subdir.)
sub cleanup_subdir {
	my $dirname = shift;
	my $files = shift;
	
	my %basenames;
	my $entry;
	
	foreach $entry (@$files) {
		$entry =~ s/\.[ch]$//;
		$basenames{$entry} = 1;
	}
	
	opendir(DIR, $dirname) || die "Can't read directory $dirname";
	while ($entry = readdir(DIR)) {
		next if $entry =~ /\.(mk|la|a|am|in)$/;
		next if $entry !~ /^([^\.]+)\.[a-zA-Z]+$/;
		if (!defined($basenames{$1})) {
			print("Removing $dirname/$entry\n");
			unlink("$dirname/$entry");
		}
	}
	closedir(DIR);
}

sub handle_subdir {
	my $dirname = shift;
	my $varname = shift;
	my $files = shift;
	
	populate_subdir($dirname, $varname, $files);
	cleanup_subdir($dirname, $files);
}


my $compiler = $ENV{"ASN1C"} ? $ENV{"ASN1C"} : "asn1c";

if ((system("$compiler 2>/dev/null") >> 8) == 127) {
	print STDERR <<EOF;
Error: Can't find asn1c.  Try adding it to your PATH or setting the ASN1C
environment variable.
EOF
	exit 1;
}

my @generated;
my @copied;
my $command = "$compiler $cflags";
my $file;
for $file (@ARGV) {
	$command .= " $file";
}
open(COMP, "-|", "$command 2>&1")
	or die "Couldn't run asn1c";
while (<COMP>) {
	if (/^Copied [^\t ]+[\t ]+-> ([a-zA-Z0-9._-]+)$/) {
		push(@copied, $1);
		next;
	}
	if (/^Compiled ([a-zA-Z0-9.-]+)/) {
		push(@generated, $1);
		next;
	}
	next if (/^Generated /);
	print STDERR;
}
close COMP;
exit $? >> 8 if $? >> 8;

unlink("Makefile.am.sample", "converter-sample.c");

handle_subdir("classes", "CLASS_FILES", \@generated);
handle_subdir("support", "SUPPORT_FILES", \@copied);

open(FH, ">stamp") || die "Can't touch stamp file";
close FH;

exit 0;
