#!/usr/bin/perl

use strict;
use warnings;
use Getopt::Std;

our $filename;
our $opt_o;
our %outfiles;

END {
	my $status = $?;
	my $file;
	foreach $file (values %outfiles) {
		unlink("$file.$$");
	}
	$? = $status;
}

sub parseErr {
	my $msg = shift;
	
	print(STDERR "$filename, line $.: $msg\n");
	exit 1;
}

sub openFile {
	my $handle = shift;
	my $name = shift;
	
	open($handle, ">", "$name.$$") || die "Can't open $name.$$";
	$outfiles{$handle} = $name;
	print $handle "/* AUTOGENERATED FILE -- DO NOT EDIT */\n\n";
}

sub closeFiles {
	my $handle;
	my $file;
	
	while (($handle, $file) = each %outfiles) {
		close($handle);
		rename("$file.$$", "$file") || die "Couldn't write $file";
		delete $outfiles{$handle};
	}
}

getopts("o:");
die "No output file specified"
	if !defined($opt_o);
openFile(*XF, "$opt_o.x");
openFile(*CCF, "${opt_o}_client.c");
openFile(*CHF, "${opt_o}_client.h");
openFile(*SCF, "${opt_o}_server.c");
openFile(*SHF, "${opt_o}_server.h");

my %types;
my $type;
# These are the primitive types that can appear as procedure parameters.
# Array types (opaque, string) and unions are not supported here.
foreach $type ("int", "unsigned", "unsigned int", "enum", "bool", "hyper",
			"unsigned hyper", "float", "double", "quadruple",
			"void") {
	$types{$type} = 1;
}

my @procNums = ({}, {});	# First hash is client, second is server
my $inProcDefs = 0;
my $isServerDefs = 0;
my $haveServerDefs = 0;
my $haveClientDefs = 0;
my $sym_re = '([a-zA-Z0-9_]+)';
my $type_re = '((unsigned\s+)?[a-zA-Z0-9_]+)';
my $noreply;
my $arg;
my $ret;
my $func;
my $num;
for $filename (@ARGV) {
	open(FH, "<", $filename)
		or die "Can't open $filename";
	while (<FH>) {
		if (!$inProcDefs) {
			if (/^\s*(client|server)procs\s+{/) {
				$inProcDefs = 1;
				$isServerDefs = ($1 eq "server");
				if ($isServerDefs) {
					parseErr("Multiple serverprocs " .
							"definitions found")
						if $haveServerDefs;
					$haveServerDefs = 1;
				} else {
					parseErr("Multiple clientprocs " .
							"definitions found")
						if $haveClientDefs;
					$haveClientDefs = 1;
				}
				next;
			}
			print XF;
			if (/^\s*(struct|enum)\s+$sym_re\s+{/o) {
				print "Found $1 $2\n";
				$types{$2} = 1;
			}
			if (/^\s*typedef\s+$sym_re\s+$type_re[<\[]?/o) {
				print "Found typedef $2\n";
				$types{$2} = 1;
			}
		} else {
			if (/}/) {
				$inProcDefs = 0;
				next;
			}
			if (/^\s*(noreply)?\s+$sym_re\(($type_re
						(,\s+$type_re)?)?\)\s*=
						\s*([1-9][0-9]*)\s*;/ox) {
				$noreply = defined($1);
				$func = $2;
				$arg = $4;
				$ret = $7;
				$num = $9;
				$arg = "void" if !defined($arg);
				$ret = "void" if !defined($ret);
				parseErr("No such type: $arg")
					if !defined($types{$arg});
				parseErr("No such type: $ret")
					if !defined($types{$ret});
				parseErr("Duplicate procedure number")
					if defined($procNums[$isServerDefs]
								->{$num});
				$procNums[$isServerDefs]->{$num}=1;
				print "noreply " if $noreply;
				print "$func($arg, $ret) = $num\n";
			} elsif (/^\s*$/) {
				next;
			} else {
				parseErr("Invalid syntax");
			}
		}
	}
	close FH;
}

closeFiles();
