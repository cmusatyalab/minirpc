#!/usr/bin/perl

use strict;
use warnings;
use Getopt::Std;

our $filename;
our $opt_o;
our %outfiles;

END {
	my $status = $?;
	my $file;
	foreach $file (values %outfiles) {
		unlink("$file.$$");
	}
	$? = $status;
}

sub parseErr {
	my $msg = shift;
	
	print(STDERR "$filename, line $.: $msg\n");
	exit 1;
}

sub openFile {
	my $handle = shift;
	my $name = shift;
	
	open($handle, ">", "$name.$$") || die "Can't open $name.$$";
	$outfiles{$handle} = $name;
	print $handle "/* AUTOGENERATED FILE -- DO NOT EDIT */\n\n";
}

sub closeFiles {
	my $handle;
	my $file;
	
	while (($handle, $file) = each %outfiles) {
		close($handle);
		rename("$file.$$", "$file") || die "Couldn't write $file";
		delete $outfiles{$handle};
	}
}

getopts("o:");
die "No output file specified"
	if !defined($opt_o);
openFile(*XF, "$opt_o.x");
openFile(*CCF, "${opt_o}_client.c");
openFile(*CHF, "${opt_o}_client.h");
openFile(*SCF, "${opt_o}_server.c");
openFile(*SHF, "${opt_o}_server.h");

my %types;
my $type;
# These are the primitive types that can appear as procedure parameters.
# Array types (opaque, string) and unions are not supported here.
foreach $type ("int", "unsigned", "unsigned int", "enum", "bool", "hyper",
			"unsigned hyper", "float", "double", "quadruple",
			"void") {
	$types{$type} = 1;
}

my %procNums;
my $inProcDefs;
my $sym_re = '([a-zA-Z0-9_]+)';
my $type_re = '((unsigned\s+)?[a-zA-Z0-9_]+)';
my $noreply;
my $arg;
my $ret;
my $func;
my $num;
for $filename (@ARGV) {
	open(FH, "<", $filename)
		or die "Can't open $filename";
	while (<FH>) {
		if (!$inProcDefs) {
			if (/^\s*(client|server)(procs|msgs)\s+{/) {
				$inProcDefs = "$1$2";
				parseErr("Multiple $inProcDefs definitions " .
							"found")
					if exists($procNums{$inProcDefs});
				$procNums{$inProcDefs} = {};
				$noreply = ($2 eq "msgs");
				next;
			}
			print XF;
			if (/^\s*(struct|enum)\s+$sym_re\s+{/o) {
				print "Found $1 $2\n";
				$types{$2} = 1;
			}
			if (/^\s*typedef\s+$sym_re\s+$type_re[<\[]?/o) {
				print "Found typedef $2\n";
				$types{$2} = 1;
			}
		} else {
			if (/}/) {
				undef $inProcDefs;
				next;
			}
			if (/^\s*$sym_re\(($type_re(,\s+$type_re)?)?\)\s*=
						\s*([1-9][0-9]*)\s*;/ox) {
				$func = $1;
				$arg = $3;
				$ret = $6;
				$num = $8;
				$arg = "void" if !defined($arg);
				$ret = "void" if !defined($ret);
				parseErr("No such type: $arg")
					if !defined($types{$arg});
				parseErr("No such type: $ret")
					if !defined($types{$ret});
				parseErr("Duplicate procedure number")
					if defined($procNums{$inProcDefs}
								->{$num});
				parseErr("Procedures in $inProcDefs section " .
							"cannot return a value")
					if $noreply && $ret ne "void";
				$procNums{$inProcDefs}->{$num}=1;
				print "$func($arg, $ret) = $num\n";
			} elsif (/^\s*$/) {
				next;
			} else {
				parseErr("Invalid syntax");
			}
		}
	}
	close FH;
}

closeFiles();
