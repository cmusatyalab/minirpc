#!/usr/bin/perl

use strict;
use warnings;
use Getopt::Std;
use File::Compare;

our $filename;
our $opt_o;
our %outfiles;
our %types;

END {
	my $status = $?;
	my $file;
	foreach $file (values %outfiles) {
		unlink("$file.$$");
	}
	$? = $status;
}

sub parseErr {
	my $msg = shift;
	
	print(STDERR "$filename, line $.: $msg\n");
	exit 1;
}

sub openFile {
	my $handle = shift;
	my $name = shift;
	
	open($handle, ">", "$name.$$") || die "Can't open $name.$$";
	$outfiles{$handle} = $name;
	print $handle "/* AUTOGENERATED FILE -- DO NOT EDIT */\n\n";
}

sub closeFiles {
	my $handle;
	my $file;
	
	while (($handle, $file) = each %outfiles) {
		close($handle);
		if (!compare("$file.$$", "$file")) {
			unlink("$file.$$");
		} else {
			rename("$file.$$", "$file") ||
				die "Couldn't write $file";
		}
		delete $outfiles{$handle};
	}
}

sub argument {
	my $type = shift;
	my $var = shift;
	
	if ($type ne "void") {
		return ", $type $var";
	} else {
		return "";
	}
}

sub parameter {
	my $type = shift;
	my $param = shift;
	
	if ($type ne "void") {
		return $param;
	} else {
		return "NULL";
	}
}

sub gen_sender_stub_c {
	my $fh = shift;
	my $func = shift;
	my $in = shift;
	my $out = shift;
	
	my $inarg = argument($in, "*in");
	my $outarg = argument($out, "**out");
	my $inparam = parameter($in, "in");
	my $outparam = parameter($out, "out");
	
	print $fh <<EOF;

int $func(struct mrpc_connection *conn$inarg$outarg)
{
	return mrpc_send_request(conn, nr_$func, $inparam, $outparam);
}

int ${func}_async(struct mrpc_connection *conn,
			${func}_callback_fn *callback,
			void *private$inarg)
{
	return mrpc_send_request_async(conn, nr_$func, $inparam, callback,
				private);
}
EOF
}

sub gen_sender_stub_sync_h {
	my $fh = shift;
	my $func = shift;
	my $in = shift;
	my $out = shift;
	
	my $inarg = argument($in, "*in");
	my $outarg = argument($out, "**out");
	
	print $fh <<EOF;
int $func(struct mrpc_connection *conn$inarg$outarg);
EOF
}

sub gen_sender_stub_typedef_h {
	my $fh = shift;
	my $func = shift;
	my $in = shift;
	my $out = shift;
	
	my $outarg = argument($out, "*reply");
	
	print $fh <<EOF;
typedef void (${func}_callback_fn)(void *conn_private,
			void *msg_private, int status$outarg);
EOF
}

sub gen_sender_stub_async_h {
	my $fh = shift;
	my $func = shift;
	my $in = shift;
	my $out = shift;
	
	my $inarg = argument($in, "*in");
	
	print $fh <<EOF;
int ${func}_async(struct mrpc_connection *conn,
			${func}_callback_fn *callback,
			void *private$inarg);
EOF
}

sub gen_receiver_stub_c {
	my $fh = shift;
	my $func = shift;
	my $in = shift;
	my $out = shift;
	
	my $outarg = argument($out, "*out");
	my $outparam = parameter($out, "out");
	
	print $fh <<EOF;

int ${func}_send_async_reply(struct mrpc_message *request,
			int status$outarg)
{
	return mrpc_send_reply(request, status$outparam);
}
EOF
}

sub gen_receiver_stub_h {
	my $fh = shift;
	my $func = shift;
	my $in = shift;
	my $out = shift;
	
	my $outarg = argument($out, "*out");
	
	print $fh <<EOF;
int ${func}_send_async_reply(struct mrpc_message *request,
			int status$outarg);
EOF
}

sub gen_oneway_stub_c {
	my $fh = shift;
	my $func = shift;
	my $in = shift;
	my $out = shift;
	
	my $inarg = argument($in, "*in");
	my $inparam = parameter($in, "in");
	
	print $fh <<EOF;

int ${func}(struct mrpc_connection *conn$inarg)
{
	return mrpc_send_request_noreply(conn, nr_$func, $inparam);
}
EOF
}

sub gen_oneway_stub_h {
	my $fh = shift;
	my $func = shift;
	my $in = shift;
	my $out = shift;
	
	my $inarg = argument($in, "*in");
	
	print $fh <<EOF;
int ${func}(struct mrpc_connection *conn$inarg);
EOF
}

sub genstubs {
	my $section = shift;
	my $procs = shift;
	my $sfh = shift;
	my $rfh = shift;
	my $noreply = shift;
	
	my $file;
	my $line;
	my $num;
	my $func;
	my $arg;
	my $ret;
	my $fh;
	
	foreach $num (sort keys %$procs) {
		($file, $line, $func, $arg, $ret, $num) = @{$procs->{$num}};
		parseErr($file, $line, "No such type: $arg")
			if !defined($types{$arg});
		parseErr($file, $line, "No such type: $ret")
			if !defined($types{$ret});
		parseErr($file, $line, "Procedures in $section section " .
					"cannot return a value")
			if $noreply && $ret ne "void";
		print "$func($arg, $ret) = $num\n";
	}
	
	if ($noreply) {
		foreach $num (sort keys %$procs) {
			($file, $line, $func, $arg, $ret, $num) =
						@{$procs->{$num}};
			gen_oneway_stub_c($sfh->[0], $func, $arg, $ret);
			gen_oneway_stub_h($sfh->[1], $func, $arg, $ret);
		}
	} else {
		foreach $num (sort keys %$procs) {
			($file, $line, $func, $arg, $ret, $num) =
						@{$procs->{$num}};
			gen_sender_stub_c($sfh->[0], $func, $arg, $ret);
			gen_receiver_stub_c($rfh->[0], $func, $arg, $ret);
			gen_sender_stub_typedef_h($sfh->[1], $func, $arg, $ret);
			gen_receiver_stub_h($rfh->[1], $func, $arg, $ret);
		}
		print {$sfh->[1]} "\n";
		foreach $num (sort keys %$procs) {
			($file, $line, $func, $arg, $ret, $num) =
						@{$procs->{$num}};
			gen_sender_stub_sync_h($sfh->[1], $func, $arg, $ret);
		}
		print {$sfh->[1]} "\n";
		foreach $num (sort keys %$procs) {
			($file, $line, $func, $arg, $ret, $num) =
						@{$procs->{$num}};
			gen_sender_stub_async_h($sfh->[1], $func, $arg, $ret);
		}
		print {$sfh->[1]} "\n";
	}
}

getopts("o:");
die "No output file specified"
	if !defined($opt_o);
openFile(*XF, "$opt_o.x");

my $type;
# These are the primitive types that can appear as procedure parameters.
# Array types (opaque, string) and unions are not supported here.
foreach $type ("int", "unsigned", "unsigned int", "enum", "bool", "hyper",
			"unsigned hyper", "float", "double", "quadruple",
			"void") {
	$types{$type} = 1;
}

my %procs;
my $curProcData;
my $curDefs;
my $sym_re = '([a-zA-Z0-9_]+)';
my $type_re = '((unsigned\s+)?[a-zA-Z0-9_]+)';
my $num;
for $filename (@ARGV) {
	open(FH, "<", $filename)
		or die "Can't open $filename";
	while (<FH>) {
		if (!$curDefs) {
			if (/^\s*(client|server)(procs|msgs)\s+{/) {
				$curDefs = "$1$2";
				parseErr($filename, $., "Multiple $curDefs" .
							" definitions found")
					if exists($procs{$curDefs});
				$procs{$curDefs} = {};
				next;
			}
			print XF;
			if (/^\s*(struct|enum)\s+$sym_re\s+{/o) {
				print "Found $1 $2\n";
				$types{$2} = 1;
			}
			if (/^\s*typedef\s+$sym_re\s+$type_re[<\[]?/o) {
				print "Found typedef $2\n";
				$types{$2} = 1;
			}
		} else {
			if (/}/) {
				undef $curDefs;
				next;
			}
			if (/^\s*$sym_re\(($type_re(,\s+$type_re)?)?\)\s*=
						\s*([1-9][0-9]*)\s*;/ox) {
				$num = $8;
				# file, line, func, arg, ret, num
				$curProcData = [$filename, $., $1,
							$3 ? $3 : "void",
							$6 ? $6 : "void", $num];
				parseErr("Duplicate procedure number")
					if defined($procs{$curDefs}->{$num});
				$procs{$curDefs}->{$num} = $curProcData;
			} elsif (/^\s*$/) {
				next;
			} else {
				parseErr($filename, $., "Invalid syntax");
			}
		}
	}
	close FH;
}

my @sfh;
my @rfh;
my $noreply;
openFile(*CCF, "${opt_o}_client.c");
openFile(*CHF, "${opt_o}_client.h");
openFile(*SCF, "${opt_o}_server.c");
openFile(*SHF, "${opt_o}_server.h");
foreach $curDefs ("serverprocs", "servermsgs", "clientprocs", "clientmsgs") {
	next if !defined($procs{$curDefs});
	if ($curDefs =~ /server/) {
		@sfh = (*CCF, *CHF);
		@rfh = (*SCF, *SHF);
	} else {
		@sfh = (*SCF, *SHF);
		@rfh = (*CCF, *CHF);
	}
	$noreply = $curDefs =~ /msgs/;
	genstubs($curDefs, $procs{$curDefs}, \@sfh, \@rfh, $noreply);
}
closeFiles();
