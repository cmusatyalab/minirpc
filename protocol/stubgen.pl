#!/usr/bin/perl

use strict;
use warnings;
use Getopt::Std;

our $filename;
our $opt_o;
our %outfiles;

END {
	my $status = $?;
	my $file;
	foreach $file (values %outfiles) {
		unlink("$file.$$");
	}
	$? = $status;
}

sub parseErr {
	my $msg = shift;
	
	print(STDERR "$filename, line $.: $msg\n");
	exit 1;
}

sub openFile {
	my $handle = shift;
	my $name = shift;
	
	open($handle, ">", "$name.$$") || die "Can't open $name.$$";
	$outfiles{$handle} = $name;
	print $handle "/* AUTOGENERATED FILE -- DO NOT EDIT */\n\n";
}

sub closeFiles {
	my $handle;
	my $file;
	
	while (($handle, $file) = each %outfiles) {
		close($handle);
		rename("$file.$$", "$file") || die "Couldn't write $file";
		delete $outfiles{$handle};
	}
}

sub gen_sender_stub {
	my $cf = shift;
	my $hf = shift;
	my $func = shift;
	my $in = shift;
	my $out = shift;
	
	print $cf <<EOF;

int $func(struct mrpc_connection *conn,
			$in *in, $out **out)
{
	return mrpc_send_request(conn, nr_$func, in, out);
}

int ${func}_async(struct mrpc_connection *conn, $in *in,
			${func}_callback_fn *callback, void *private)
{
	return mrpc_send_request_async(conn, nr_$func, in, callback,
				private);
}
EOF

	print $hf <<EOF;

int $func(struct mrpc_connection *conn,
			$in *in, $out **out);
typedef void (${func}_callback_fn)(void *conn_private,
			void *msg_private, int status, $out *reply);
int ${func}_async(struct mrpc_connection *conn, $in *in,
			${func}_callback_fn *callback, void *private);
EOF
}

sub gen_receiver_stub {
	my $cf = shift;
	my $hf = shift;
	my $func = shift;
	my $in = shift;
	my $out = shift;
	
	print $cf <<EOF;

int ${func}_send_async_reply(struct mrpc_message *request,
			int status, $out *out)
{
	return mrpc_send_reply(request, status, out);
}
EOF

	print $hf <<EOF;
int ${func}_send_async_reply(struct mrpc_message *request,
			int status, $out *out);
EOF
}

sub gen_oneway_stub {
	my $cf = shift;
	my $hf = shift;
	my $func = shift;
	my $in = shift;
	my $out = shift;
	
	print $cf <<EOF;

int ${func}_oneway(struct mrpc_connection *conn, $in *in)
{
	return mrpc_send_request_noreply(conn, nr_$func, in);
}
EOF

	print $cf <<EOF;

int ${func}_oneway(struct mrpc_connection *conn, $in *in)
EOF
}

getopts("o:");
die "No output file specified"
	if !defined($opt_o);
openFile(*XF, "$opt_o.x");
openFile(*CCF, "${opt_o}_client.c");
openFile(*CHF, "${opt_o}_client.h");
openFile(*SCF, "${opt_o}_server.c");
openFile(*SHF, "${opt_o}_server.h");

my %types;
my $type;
# These are the primitive types that can appear as procedure parameters.
# Array types (opaque, string) and unions are not supported here.
foreach $type ("int", "unsigned", "unsigned int", "enum", "bool", "hyper",
			"unsigned hyper", "float", "double", "quadruple",
			"void") {
	$types{$type} = 1;
}

my %procNums;
my $inProcDefs;
my $sym_re = '([a-zA-Z0-9_]+)';
my $type_re = '((unsigned\s+)?[a-zA-Z0-9_]+)';
my @sfh;
my @rfh;
my $noreply;
my $arg;
my $ret;
my $func;
my $num;
for $filename (@ARGV) {
	open(FH, "<", $filename)
		or die "Can't open $filename";
	while (<FH>) {
		if (!$inProcDefs) {
			if (/^\s*(client|server)(procs|msgs)\s+{/) {
				$inProcDefs = "$1$2";
				parseErr("Multiple $inProcDefs definitions " .
							"found")
					if exists($procNums{$inProcDefs});
				$procNums{$inProcDefs} = {};
				if ($1 eq "server") {
					@sfh = (*CCF, *CHF);
					@rfh = (*SCF, *SHF);
				} else {
					@sfh = (*SCF, *SHF);
					@rfh = (*CCF, *CHF);
				}
				$noreply = ($2 eq "msgs");
				next;
			}
			print XF;
			if (/^\s*(struct|enum)\s+$sym_re\s+{/o) {
				print "Found $1 $2\n";
				$types{$2} = 1;
			}
			if (/^\s*typedef\s+$sym_re\s+$type_re[<\[]?/o) {
				print "Found typedef $2\n";
				$types{$2} = 1;
			}
		} else {
			if (/}/) {
				undef $inProcDefs;
				next;
			}
			if (/^\s*$sym_re\(($type_re(,\s+$type_re)?)?\)\s*=
						\s*([1-9][0-9]*)\s*;/ox) {
				$func = $1;
				$arg = $3;
				$ret = $6;
				$num = $8;
				$arg = "void" if !defined($arg);
				$ret = "void" if !defined($ret);
				parseErr("No such type: $arg")
					if !defined($types{$arg});
				parseErr("No such type: $ret")
					if !defined($types{$ret});
				parseErr("Duplicate procedure number")
					if defined($procNums{$inProcDefs}
								->{$num});
				parseErr("Procedures in $inProcDefs section " .
							"cannot return a value")
					if $noreply && $ret ne "void";
				$procNums{$inProcDefs}->{$num}=1;
				print "$func($arg, $ret) = $num\n";
				if ($noreply) {
					gen_oneway_stub($sfh[0], $sfh[1],
						$func, $arg, $ret);
				} else {
					gen_sender_stub($sfh[0], $sfh[1],
						$func, $arg, $ret);
					gen_receiver_stub($rfh[0], $rfh[1],
						$func, $arg, $ret);
				}
			} elsif (/^\s*$/) {
				next;
			} else {
				parseErr("Invalid syntax");
			}
		}
	}
	close FH;
}

closeFiles();
