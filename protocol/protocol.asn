OPENISR -- { XXXoid }
DEFINITIONS
AUTOMATIC TAGS ::=
BEGIN

ChunkID ::= INTEGER (0..MAX)
ParcelVer ::= INTEGER (0..MAX)
Hash ::= OCTET STRING (SIZE (16..64))
EncryptedKeyRecord ::= OCTET STRING
String ::= UTF8String

DateRange ::= SEQUENCE {
	start GeneralizedTime,
	stop GeneralizedTime
}

KeyRecord ::= SEQUENCE {
	key Hash,
	compress Compression,
	encrypt Encryption
}

Compression ::= ENUMERATED {
	none,
	zlib,
	lzf
}

Encryption ::= ENUMERATED {
	blowfish-sha1,
	none-sha1
}

Want ::= BIT STRING {
	key (0),
	data (1)
}

ClientHello ::= SEQUENCE {
	software String,
	version String,
	...
}

ServerHello ::= SEQUENCE {
	software String,
	version String,
	...
}

Status ::= ENUMERATED {
	ok,
	message-unknown,
	tls-required,
	parcel-locked,
	no-such-parcel,
	no-such-version,
	no-such-chunk,
	...
}

/* XXX need a way to change password */
/* XXX need a way to force password change */

/* @force can be declined if an open connection currently exists which holds
   the lock? */
-- Define    : request
-- Replies   : Status
-- Multireply: no
-- Initiators: client
AcquireLock ::= SEQUENCE {
	parcel String,
	version ParcelVer,
	nonce INTEGER OPTIONAL,
	force BOOLEAN,
	...
}

-- Define    : request
-- Replies   : Status
-- Multireply: no
-- Initiators: client
ReleaseLock ::= SEQUENCE {
	parcel String,
	nonce INTEGER,
	...
}



-- Define    : request
-- Replies   : ListParcelsReply
-- Multireply: no
-- Initiators: client
ListParcels ::= SEQUENCE {
	name String OPTIONAL,
	history DateRange OPTIONAL,
	...
}

ListParcelsReply ::= SEQUENCE OF ParcelInfo

ParcelInfo ::= SEQUENCE {
	name String,
	comment String OPTIONAL,
	current ParcelVersionInfo,
	acquired ParcelLockInfo OPTIONAL,
	history SEQUENCE OF ParcelVersionInfo,
	...
}

ParcelVersionInfo ::= SEQUENCE {
	version ParcelVer,
	comment String OPTIONAL,
	checkin GeneralizedTime,
	chunks INTEGER (0..MAX),		/* unique chunks */
	...
}

ParcelLockInfo ::= SEQUENCE {
	version ParcelVersionInfo,
	by String,
	at GeneralizedTime,
	comment String OPTIONAL,
	...
}


-- Define    : request
-- Replies   : Status
-- Multireply: no
-- Initiators: client
ParcelCheckout ::= SEQUENCE {
	name String,
	version ParcelVer,
	owner String,
	comment String OPTIONAL,
	...
}


AddParcel ::= SEQUENCE {
	name String,
	comment String OPTIONAL,
	...
}

RemoveParcel ::= SEQUENCE {
	name String,
	version ParcelVer
}

-- can use this to ask what chunks are needed for upload?  we need to provide
-- a mechanism to lock chunks from GCing if we're about to upload them.
-- what if we upload the keyring first?
-- Define    : request
-- Replies   : ChunkReply
-- Multireply: yes
-- Initiators: client server
ChunkRequest ::= SEQUENCE {
	key CHOICE {
		cid ChunkID,
		tag Hash
	},
	want Want,
	...
}

ChunkReply ::= SEQUENCE {
	status Status DEFAULT ok,  -- XXX may be encoded if specified, in violation of DER
	keyrec EncryptedKeyRecord OPTIONAL,
	data OCTET STRING (SIZE (1..131072)) OPTIONAL
}

-- should chunkrequest/chunkreply be bidirectional?  (it'd be chunkprovide
-- or something rather than chunkreply.)  has a nice symmetry to it.  but
-- then we'd need support for putting the tag in the reply, for unsolicited
-- uploads.

-- we may want a SET OF keyrecs.

-- should we upload the keyring entries along with the associated chunk, or
-- should keyring and data upload be separate?  the former requires some way
-- to mark a keyring as in-progress.  or, we could just have temporary keyrings
-- which can be committed.  after we commit to them they're immutable
ChunkUpload ::= SEQUENCE {
	
}

-- Define: choice
ISRMessageBody ::= CHOICE {
	status Status,
	serverhello ServerHello,
	clienthello ClientHello,
	chunkrequest ChunkRequest,
	data ChunkReply,
	acquire AcquireLock,
	release ReleaseLock,
	starttls NULL,
	...
}

MessageDirection ::= ENUMERATED {
	request,
	reply,
	last-reply
}

ISRMessage ::= SEQUENCE {
	sequence INTEGER (0..MAX),
	direction MessageDirection,
	body ISRMessageBody
}

END
