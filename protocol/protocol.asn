OPENISR -- { XXXoid }
DEFINITIONS
AUTOMATIC TAGS ::=
BEGIN

ChunkID ::= INTEGER (0..MAX)
ParcelVer ::= INTEGER (0..MAX)
Hash ::= OCTET STRING (SIZE (16..64))
EncryptedKeyRecord ::= OCTET STRING
String ::= UTF8String (SIZE (1..80))

KeyRecord ::= SEQUENCE {
	key Hash,
	compress Compression,
	encrypt Encryption
}

Compression ::= ENUMERATED {
	none,
	zlib,
	lzf
}

Encryption ::= ENUMERATED {
	blowfish-sha1,
	none-sha1
}

Want ::= BIT STRING {
	key (0),
	data (1)
}

ClientHello ::= SEQUENCE {
	software String,
	version String,
	...
}

ServerHello ::= SEQUENCE {
	software String,
	version String,
	...
}

Status ::= ENUMERATED {
	ok,
	message-unknown,
	no-chunk,
	parcel-locked,
	no-such-version,
	tls-required,
	...
}

-- need a way to change password
-- need a way to force password change

-- Define    : request
-- Replies   : Status
-- Multireply: no
-- Initiators: client
AcquireLock ::= SEQUENCE {
	parcel String,
	version ParcelVer,
	force BOOLEAN,
	...
}

-- Define    : request
-- Replies   : Status
-- Multireply: no
-- Initiators: client
ReleaseLock ::= SEQUENCE {
	parcel String,
	nonce INTEGER,
	...
}

ListParcels ::= SEQUENCE {
	name String OPTIONAL,
	versions INTEGER (-1..MAX),  -- -1 == all
	...
}

ParcelRecord ::= SEQUENCE {
	name String,
	size INTEGER (0..MAX), -- unique chunks
	version ParcelVer,
	checkin GeneralizedTime,
	acquired SEQUENCE {
		by String,
		at GeneralizedTime
	} OPTIONAL,
	...
}

ListParcelReply ::= SEQUENCE OF ParcelRecord

-- can use this to ask what chunks are needed for upload?  we need to provide
-- a mechanism to lock chunks from GCing if we're about to upload them.
-- what if we upload the keyring first?
-- Define    : request
-- Replies   : ChunkReply
-- Multireply: yes
-- Initiators: client server
ChunkRequest ::= SEQUENCE {
	key CHOICE {
		cid ChunkID,
		tag Hash
	},
	want Want,
	...
}

ChunkReply ::= SEQUENCE {
	status Status DEFAULT ok,  -- XXX may be encoded if specified, in violation of DER
	keyrec EncryptedKeyRecord OPTIONAL,
	data OCTET STRING (SIZE (1..131072)) OPTIONAL
}

-- should chunkrequest/chunkreply be bidirectional?  (it'd be chunkprovide
-- or something rather than chunkreply.)  has a nice symmetry to it.  but
-- then we'd need support for putting the tag in the reply, for unsolicited
-- uploads.

-- we may want a SET OF keyrecs.

-- should we upload the keyring entries along with the associated chunk, or
-- should keyring and data upload be separate?  the former requires some way
-- to mark a keyring as in-progress.  or, we could just have temporary keyrings
-- which can be committed.  after we commit to them they're immutable
ChunkUpload ::= SEQUENCE {
	
}

-- Define: choice
ISRMessageBody ::= CHOICE {
	status Status,
	serverhello ServerHello,
	clienthello ClientHello,
	chunkrequest ChunkRequest,
	data ChunkReply,
	acquire AcquireLock,
	release ReleaseLock,
	starttls NULL,
	...
}

MessageDirection ::= ENUMERATED {
	request,
	reply,
	last-reply
}

ISRMessage ::= SEQUENCE {
	sequence INTEGER (0..MAX),
	direction MessageDirection,
	body ISRMessageBody
}

END
