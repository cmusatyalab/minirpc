OPENISR /* XXX need OID */
DEFINITIONS
AUTOMATIC TAGS ::=
BEGIN

/*** Generic types ***********************************************************/

ChunkID			::= INTEGER (0..MAX)
ParcelVer		::= INTEGER (0..MAX)
Hash			::= OCTET STRING (SIZE (16..64))
EncryptedKeyRecord	::= OCTET STRING
String			::= UTF8String

DateRange ::= SEQUENCE {
	start		GeneralizedTime,
	stop		GeneralizedTime
}

KeyRecord ::= SEQUENCE {
	key		Hash,
	compress	Compression,
	encrypt		Encryption
}

Compression ::= ENUMERATED {
	none,
	zlib,
	lzf,
	...
}

Encryption ::= ENUMERATED {
	none-sha1,
	blowfish-sha1,
	aes-sha1,
	...
}

-- Define:	reply
Status ::= ENUMERATED {
	ok,
	continue,		/* authentication incomplete */
	message-unknown,
	not-supported,
	tls-required,
	not-authenticated,
	auth-failed,
	parcel-locked,
	no-such-parcel,
	no-such-version,
	no-such-record,
	no-data,
	quota-exceeded,
	...
}

/*** Startup and authentication messages *************************************/

-- Define:	request
-- Replies:	ClientHello
-- Initiators:	server
ServerHello ::= SEQUENCE {
	software	String,
	version		String,
	banner		String,
	protocolSupport	SupportedProtocolVersions,
	tlsSupported	BOOLEAN,
	tlsRequired	BOOLEAN,
	authTypes	String			/* space-separated */ /* XXX */
}

SupportedProtocolVersions ::= BIT STRING {
	v0 (0)
}

-- Define:	reply
ClientHello ::= SEQUENCE {
	software	String,
	version		String,
	protocolChosen	INTEGER
}

-- Define:	request
-- Replies:	Status
-- Initiators:	client
StartTLS ::= NULL

-- Define:	request
-- Replies:	AuthReply
-- Initiators:	client
Authenticate ::= SEQUENCE {
	method		String,
	data		OCTET STRING
}

-- Define:	request
-- Replies:	AuthReply
-- Initiators:	client
AuthStep ::= OCTET STRING

-- Define:	reply
AuthReply ::= SEQUENCE {
	status		Status,
	message		String OPTIONAL,
	data		OCTET STRING
}

/* XXX should password changing be part of the protocol? */

/*** Parcel operations *******************************************************/

/* @force can be declined if an open connection currently exists which holds
   the lock? */
-- Define:	request
-- Replies:	NewCookie Status
-- Initiators:	client
AcquireLock ::= SEQUENCE {
	parcel		String,
	version		ParcelVer,
	owner		String,
	comment		String OPTIONAL,
	cookie		INTEGER OPTIONAL,
	force		BOOLEAN,
	...
}

-- Define:	reply
NewCookie ::= INTEGER

-- Define:	request
-- Replies:	Status
-- Initiators:	client
ReleaseLock ::= SEQUENCE {
	parcel		String,
	cookie		INTEGER,
	...
}

/* On checkout, a temporary area for keyring updates is (logically) created
   and is based on the keyring version that was checked out.  Keyring updates
   may then be sent, and may supersede previous keyring updates.  Chunk uploads
   may be made against the keys in the temporary keyring.  Commit will not
   be allowed until every new key has the corresponding chunk data. */

-- Define:	request
-- Replies:	Status NeedTags
-- Initiators:	client
ParcelCommit ::= SEQUENCE {
	parcel		String,
	comment		String,
	...
}

-- Define:	reply
NeedTags ::= SEQUENCE OF Hash

-- Define:	request
-- Replies:	Status
-- Initiators:	client
AddParcel ::= SEQUENCE {
	parcel		String,
	comment		String OPTIONAL,
	chunks		INTEGER (0..MAX),
	...
}

-- Define:	request
-- Replies:	Status
-- Initiators:	client
UpdateParcel ::= SEQUENCE {
	parcel 		String,
	comment		String OPTIONAL,
	...
}

-- Define:	request
-- Replies:	Status
-- Initiators:	client
RemoveParcel ::= SEQUENCE {
	parcel		String,
	version		ParcelVer OPTIONAL
}

/*** ListParcels *************************************************************/

-- Define:	request
-- Replies:	ListParcelsReply
-- Initiators:	client
ListParcels ::= SEQUENCE {
	name		String OPTIONAL,
	history		DateRange OPTIONAL,
	...
}

-- Define:	reply
ListParcelsReply ::= SEQUENCE OF ParcelInfo

ParcelInfo ::= SEQUENCE {
	name		String,
	comment		String OPTIONAL,
	current		ParcelVersionInfo,
	acquired	ParcelLockInfo OPTIONAL,
	history		SEQUENCE OF ParcelVersionInfo,
	...
}

ParcelVersionInfo ::= SEQUENCE {
	version		ParcelVer,
	comment		String OPTIONAL,
	checkin		GeneralizedTime,
	chunks		INTEGER (0..MAX),		/* unique chunks */
	...
}

ParcelLockInfo ::= SEQUENCE {
	version		ParcelVersionInfo,
	by		String,
	at		GeneralizedTime,
	comment		String OPTIONAL,
	...
}

/*** Chunk operations ********************************************************/

/* can use this to ask what chunks are needed for upload?  we need to provide
   a mechanism to lock chunks from GCing if we're about to upload them.
   what if we upload the keyring first? */
-- Define:	request
-- Replies:	ChunkReply Status
-- Initiators:	client
ChunkRequest ::= SEQUENCE {
	by		ChunkLookupKey,
	want		WantChunkInfo,
	...
}

ChunkLookupKey ::= CHOICE {
	chunk		ChunkID,
	tag		Hash
}

WantChunkInfo ::= BIT STRING {
	chunks (0),
	key (1),
	data (2)
}

-- Define:	reply
ChunkReply ::= SEQUENCE {
	chunks		SET OF ChunkID OPTIONAL,
	keyrec		EncryptedKeyRecord OPTIONAL,
	data		OCTET STRING (SIZE (1..131072)) OPTIONAL,
	...
}

-- Define:	request
-- Replies:	Status
-- Initiators:	client
KeyUpdate ::= SEQUENCE {
	chunks		SET OF ChunkID,
	tag		Hash,
	keyrec		EncryptedKeyRecord,
	...
}

-- Define:	request
-- Replies:	Status
-- Initiators:	client
ChunkUpload ::= SEQUENCE {
	tag		Hash,
	data		OCTET STRING (SIZE (1..131072))
}

/*** Miscellaneous messages **************************************************/

-- Define:	request
-- Replies:	Status
-- Initiators:	client server
Ping ::= NULL

/*** Top-level message *******************************************************/

-- Define:	parent
MessageBody ::= CHOICE {
	status		Status,
	ping		Ping,
	
	serverhello	ServerHello,
	clienthello	ClientHello,
	
	starttls	StartTLS,
	auth		Authenticate,
	authstep	AuthStep,
	authreply	AuthReply,
	
	acquire		AcquireLock,
	cookie		NewCookie,
	release		ReleaseLock,
	add		AddParcel,
	update		UpdateParcel,
	remove		RemoveParcel,
	commit		ParcelCommit,
	needtags	NeedTags,
	
	list		ListParcels,
	listreply	ListParcelsReply,
	
	chunkrequest	ChunkRequest,
	data		ChunkReply,
	keyupdate	KeyUpdate,
	upload		ChunkUpload,
	
	...
}

ISRMessage ::= SEQUENCE {
	sequence	INTEGER (0..MAX),
	isReply		BOOLEAN,
	body		MessageBody
}

END
