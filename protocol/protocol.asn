OPENISR /* XXX need OID */
DEFINITIONS
AUTOMATIC TAGS ::=
BEGIN

/*** Generic types ***********************************************************/

ChunkID			::= INTEGER (0..MAX)
ParcelVer		::= INTEGER (0..MAX)
Hash			::= OCTET STRING (SIZE (16..64))
EncryptedKeyRecord	::= OCTET STRING
String			::= UTF8String

DateRange ::= SEQUENCE {
	start		GeneralizedTime,
	stop		GeneralizedTime
}

KeyRecord ::= SEQUENCE {
	key		Hash,
	compress	Compression,
	encrypt		Encryption
}

Compression ::= ENUMERATED {
	none,
	zlib,
	lzf
}

Encryption ::= ENUMERATED {
	blowfish-sha1,
	none-sha1
}

WantChunkInfo ::= BIT STRING {
	key (0),
	data (1)
}

-- Define:	reply
Status ::= ENUMERATED {
	ok,
	message-unknown,
	tls-required,
	auth-failed,
	parcel-locked,
	no-such-parcel,
	no-such-version,
	no-such-chunk,
	need-data,
	...
}

/*** Startup and authentication messages *************************************/

-- Define:	request
-- Replies:	ClientHello
-- Initiators:	server
ServerHello ::= SEQUENCE {
	software	String,
	version		String,
	banner		String,
	protocolSupport	SupportedProtocolVersions,
	tlsSupported	BOOLEAN,
	tlsRequired	BOOLEAN,
	authTypes	String			/* space-separated */ /* XXX */
}

SupportedProtocolVersions ::= BIT STRING {
	v0 (0)
}

-- Define:	reply
ClientHello ::= SEQUENCE {
	software	String,
	version		String,
	protocolChosen	INTEGER
}

-- Define:	request
-- Replies:	Status
-- Initiators:	client
StartTLS ::= NULL

-- Define:	request
-- Replies:	AuthReply
-- Initiators:	client
Authenticate ::= SEQUENCE {
	method		String,
	data		OCTET STRING
}

-- Define:	request
-- Replies:	AuthReply
-- Initiators:	client
AuthStep ::= OCTET STRING

-- Define:	reply
AuthReply ::= SEQUENCE {
	status		Status,
	message		String OPTIONAL,
	data		OCTET STRING
}

/* XXX should password changing be part of the protocol? */

/*** Parcel operations *******************************************************/

/* @force can be declined if an open connection currently exists which holds
   the lock? */
-- Define:	request
-- Replies:	Status
-- Initiators:	client
AcquireLock ::= SEQUENCE {
	parcel		String,
	version		ParcelVer,
	nonce		INTEGER OPTIONAL,
	force		BOOLEAN,
	...
}

-- Define:	request
-- Replies:	Status
-- Initiators:	client
ReleaseLock ::= SEQUENCE {
	parcel String,
	nonce INTEGER,
	...
}

-- Define:	request
-- Replies:	Status
-- Initiators:	client
ParcelCheckout ::= SEQUENCE {
	name		String,
	version		ParcelVer,
	owner		String,
	comment		String OPTIONAL,
	...
}


AddParcel ::= SEQUENCE {
	name		String,
	comment		String OPTIONAL,
	...
}

RemoveParcel ::= SEQUENCE {
	name		String,
	version		ParcelVer
}

/*** ListParcels *************************************************************/

-- Define:	request
-- Replies:	ListParcelsReply
-- Initiators:	client
ListParcels ::= SEQUENCE {
	name		String OPTIONAL,
	history		DateRange OPTIONAL,
	...
}

-- Define:	reply
ListParcelsReply ::= SEQUENCE OF ParcelInfo

ParcelInfo ::= SEQUENCE {
	name		String,
	comment		String OPTIONAL,
	current		ParcelVersionInfo,
	acquired	ParcelLockInfo OPTIONAL,
	history		SEQUENCE OF ParcelVersionInfo,
	...
}

ParcelVersionInfo ::= SEQUENCE {
	version		ParcelVer,
	comment		String OPTIONAL,
	checkin		GeneralizedTime,
	chunks		INTEGER (0..MAX),		/* unique chunks */
	...
}

ParcelLockInfo ::= SEQUENCE {
	version		ParcelVersionInfo,
	by		String,
	at		GeneralizedTime,
	comment		String OPTIONAL,
	...
}

/*** Chunk operations ********************************************************/

/* can use this to ask what chunks are needed for upload?  we need to provide
   a mechanism to lock chunks from GCing if we're about to upload them.
   what if we upload the keyring first? */
-- Define:	request
-- Replies:	ChunkReply
-- Initiators:	client server
ChunkRequest ::= SEQUENCE {
	by CHOICE {
		cid	ChunkID,
		tag	Hash
	},
	want		WantChunkInfo,
	...
}

-- Define:	reply
ChunkReply ::= SEQUENCE {
	status		Status DEFAULT ok,
	keyrec		EncryptedKeyRecord OPTIONAL,
	data		OCTET STRING (SIZE (1..131072)) OPTIONAL
}

/* should chunkrequest/chunkreply be bidirectional?  (it'd be chunkprovide
   or something rather than chunkreply.)  has a nice symmetry to it.  but
   then we'd need support for putting the tag in the reply, for unsolicited
   uploads. */

/* we may want a SET OF keyrecs. */

/* should we upload the keyring entries along with the associated chunk, or
   should keyring and data upload be separate?  the former requires some way
   to mark a keyring as in-progress.  or, we could just have temporary keyrings
   which can be committed.  after we commit to them they're immutable */

-- Define:	request
-- Replies:	Status
-- Initiators:	client
KeyUpdate ::= SEQUENCE {
	keyrec		EncryptedKeyRecord
}

ChunkUpload ::= SEQUENCE {
	tag		Hash,
	data		OCTET STRING (SIZE (1..131072))
}

CommitVersion ::= SEQUENCE {

}

/*** Top-level message *******************************************************/

-- Define: parent
MessageBody ::= CHOICE {
	status		Status,
	serverhello	ServerHello,
	clienthello	ClientHello,
	auth		Authenticate,
	authstep	AuthStep,
	authreply	AuthReply,
	chunkrequest	ChunkRequest,
	data		ChunkReply,
	acquire		AcquireLock,
	release		ReleaseLock,
	checkout	ParcelCheckout,
	list		ListParcels,
	listreply	ListParcelsReply,
	keyupdate	KeyUpdate,
	starttls	StartTLS,
	...
}

ISRMessage ::= SEQUENCE {
	sequence	INTEGER (0..MAX),
	isReply		BOOLEAN,
	body		MessageBody
}

END
