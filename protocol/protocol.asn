OPENISR /* XXX need OID */
DEFINITIONS
AUTOMATIC TAGS ::=
BEGIN

/*** Generic types ***********************************************************/

ParcelVer		::= INTEGER (0..MAX)
Hash			::= OCTET STRING (SIZE (16..64))
EncryptedKeyRecord	::= OCTET STRING
EncryptedKeyRootRecord	::= OCTET STRING
String			::= UTF8String

ChunkID	::= SEQUENCE {
	cid		INTEGER (0..MAX),
	plane		ChunkPlane
}

ChunkPlane ::= ENUMERATED {
	disk,
	memory,
	...
}

DateRange ::= SEQUENCE {
	start		GeneralizedTime,
	stop		GeneralizedTime
}

KeyRecord ::= SEQUENCE {
	key		Hash,
	compress	Compression,
	encrypt		Encryption
}

KeyRootRecord ::= SEQUENCE {
	key		OCTET STRING
}

Compression ::= ENUMERATED {
	none,
	zlib,
	lzf,
	...
}

Encryption ::= ENUMERATED {
	none-sha1,
	blowfish-sha1,
	aes-sha1,
	...
}

-- Define:	reply
Status ::= ENUMERATED {
	ok,
	continue,		/* authentication incomplete */
	message-unknown,
	message-too-large,
	not-supported,
	tls-required,
	not-authenticated,
	auth-failed,
	parcel-locked,
	no-such-parcel,
	no-such-version,
	no-such-record,
	no-data,
	data-incomplete,	/* XXX redundant? */
	quota-exceeded,
	...
}

/*** Startup and authentication messages *************************************/

-- Define:	request
-- Replies:	ClientHello
-- Initiators:	server
ServerHello ::= SEQUENCE {
	software	String,
	version		String,
	banner		String OPTIONAL,
	protocolSupport	SupportedProtocolVersions,
	tlsSupported	BOOLEAN,
	tlsRequired	BOOLEAN,
	authTypes	String			/* space-separated */ /* XXX */
}

SupportedProtocolVersions ::= BIT STRING {
	v0 (0)
}

-- Define:	reply
ClientHello ::= SEQUENCE {
	software	String,
	version		String,
	protocolChosen	INTEGER
}

-- Define:	request
-- Replies:	Status
-- Initiators:	client
StartTLS ::= NULL

-- Define:	request
-- Replies:	AuthReply
-- Initiators:	client
Authenticate ::= SEQUENCE {
	method		String,
	data		OCTET STRING
}

-- Define:	request
-- Replies:	AuthReply
-- Initiators:	client
AuthStep ::= OCTET STRING

-- Define:	reply
AuthReply ::= SEQUENCE {
	status		Status,
	message		String OPTIONAL,
	data		OCTET STRING
}

/* XXX should password changing be part of the protocol?  could provide a
   "get password change URL" message for user experience. */

/*** Parcel operations *******************************************************/

/* @force can be declined if an open connection currently exists which holds
   the lock? */
-- Define:	request
-- Replies:	NewCookie Status
-- Initiators:	client
AcquireLock ::= SEQUENCE {
	parcel		String,
	version		ParcelVer,
	owner		String,
	comment		String OPTIONAL,
	cookie		INTEGER OPTIONAL,
	force		BOOLEAN,
	...
}

-- Define:	reply
NewCookie ::= INTEGER

-- Define:	request
-- Replies:	Status
-- Initiators:	client
ReleaseLock ::= SEQUENCE {
	parcel		String,
	cookie		INTEGER,
	...
}

/* On checkout, a temporary area for keyring updates is (logically) created
   and is based on the keyring version that was checked out.  Keyring updates
   may then be sent, and may supersede previous keyring updates.  Chunk uploads
   may be made against the keys in the temporary keyring.  Commit will not
   be allowed until every new key has the corresponding chunk data. */

-- Define:	request
-- Replies:	Status
-- Initiators:	client
ParcelCommit ::= SEQUENCE {
	parcel		String,
	comment		String,
	...
}

-- Define:	request
-- Replies:	Status
-- Initiators:	client
AddParcel ::= SEQUENCE {
	parcel		String,
	comment		String OPTIONAL,
	chunks		INTEGER (0..MAX),
	root		EncryptedKeyRootRecord,
	...
}

-- Define:	request
-- Replies:	Status
-- Initiators:	client
UpdateParcel ::= SEQUENCE {
	parcel 		String,
	comment		String OPTIONAL,
	...
}

-- Define:	request
-- Replies:	Status
-- Initiators:	client
UpdateKeyRoot ::= SEQUENCE {
	root		EncryptedKeyRootRecord,
	...
}

-- Define:	request
-- Replies:	Status
-- Initiators:	client
RemoveParcel ::= SEQUENCE {
	parcel		String,
	version		ParcelVer OPTIONAL
}

/*** ListParcels *************************************************************/

-- Define:	request
-- Replies:	ListParcelsReply
-- Initiators:	client
ListParcels ::= SEQUENCE {
	name		String OPTIONAL,
	history		DateRange OPTIONAL,
	...
}

-- Define:	reply
ListParcelsReply ::= SEQUENCE OF ParcelInfo

ParcelInfo ::= SEQUENCE {
	name		String,
	comment		String OPTIONAL,
	current		ParcelVersionInfo,
	acquired	ParcelLockInfo OPTIONAL,
	history		SEQUENCE OF ParcelVersionInfo,
	...
}

ParcelVersionInfo ::= SEQUENCE {
	version		ParcelVer,
	comment		String OPTIONAL,
	checkin		GeneralizedTime,
	chunks		INTEGER (0..MAX),		/* unique chunks */
	...
}

ParcelLockInfo ::= SEQUENCE {
	version		ParcelVersionInfo,
	by		String,
	at		GeneralizedTime,
	comment		String OPTIONAL,
	...
}

/*** Chunk operations ********************************************************/

-- Define:	request
-- Replies:	ChunkReply Status
-- Initiators:	client
ChunkRequest ::= SEQUENCE {
	by		ChunkLookupKey,
	want		WantChunkInfo,
	...
}

ChunkLookupKey ::= CHOICE {
	chunk		ChunkID,
	tag		Hash
}

WantChunkInfo ::= BIT STRING {
	chunks (0),
	key (1),
	data (2)
}

-- Define:	reply
ChunkReply ::= SEQUENCE {
	chunks		SET OF ChunkID OPTIONAL,
	keyrec		EncryptedKeyRecord OPTIONAL,
	data		OCTET STRING (SIZE (1..131072)) OPTIONAL,
	...
}

-- Define:	request
-- Replies:	Status
-- Initiators:	client
KeyUpdate ::= SEQUENCE {
	chunks		SET OF ChunkID,
	tag		Hash,
	keyrec		EncryptedKeyRecord,
	...
}

-- Define:	request
-- Replies:	Status
-- Initiators:	client
ChunkUpload ::= SEQUENCE {
	tag		Hash,
	data		OCTET STRING (SIZE (1..131072)),
	...
}

-- Define:	request
-- Replies:	NeedTags Status
-- Initiators:	client
GetMissingData ::= SEQUENCE {
	parcel		String,
	startIndex	INTEGER (0..MAX),	/* message size limit applies */
	stopIndex	INTEGER (0..MAX) OPTIONAL,
	...
}

-- Define:	reply
NeedTags ::= SEQUENCE OF Hash

/*** Miscellaneous messages **************************************************/

-- Define:	request
-- Replies:	Status
-- Initiators:	client server
Ping ::= NULL

/*** Top-level message *******************************************************/

-- Define:	parent
MessageBody ::= CHOICE {
	status		Status,
	ping		Ping,
	
	serverhello	ServerHello,
	clienthello	ClientHello,
	
	starttls	StartTLS,
	auth		Authenticate,
	authstep	AuthStep,
	authreply	AuthReply,
	
	acquire		AcquireLock,
	cookie		NewCookie,
	release		ReleaseLock,
	add		AddParcel,
	update		UpdateParcel,
	rootupdate	UpdateKeyRoot,
	remove		RemoveParcel,
	commit		ParcelCommit,
	
	list		ListParcels,
	listreply	ListParcelsReply,
	
	chunkrequest	ChunkRequest,
	data		ChunkReply,
	keyupdate	KeyUpdate,
	upload		ChunkUpload,
	getmissing	GetMissingData,
	needtags	NeedTags,
	
	...
}

ISRMessage ::= SEQUENCE {
	sequence	INTEGER (0..MAX),
	isReply		BOOLEAN,
	body		MessageBody
}

END
