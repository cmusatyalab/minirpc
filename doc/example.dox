/*
 * miniRPC - TCP RPC library with asynchronous operations
 *
 * Copyright (C) 2007-2008 Carnegie Mellon University
 *
 * This software is distributed under the terms of the Eclipse Public License,
 * Version 1.0 which can be found in the file named LICENSE.  ANY USE,
 * REPRODUCTION OR DISTRIBUTION OF THIS SOFTWARE CONSTITUTES RECIPIENT'S
 * ACCEPTANCE OF THIS AGREEMENT
 */

/**

@defgroup example Example Protocol
@{
@brief Protocol-dependent API for an example protocol

Much of the miniRPC interface is specific to the application protocol being
implemented on top of miniRPC.  The code to implement this interface is
generated by @c minirpcgen from a ".mx" or protocol definition file.  For
this documentation, we will illustrate the protocol-dependent interfaces
using a simple example protocol.

A protocol definition file describes the data structures and procedure calls
to be supported by the protocol.  The data structures are defined using
XDRL, the External Data Representation Language, defined in
<a href="http://www.ietf.org/rfc/rfc1832.txt">RFC 1832</a>.  The procedure
calls are defined using a syntax specific to miniRPC.

First, we examine the protocol definition for our example protocol.

@section example_mx The example.mx File
@dontinclude example.mx
@until };
@until };

The example protocol starts out by defining a Color enumeration, and then
defines a ColorChoice structure which will be used as the basis of a protocol
message.  ColorChoice contains a variable-length array of "acceptable" colors,
and one particular color which is selected as "preferred".

@until Count

miniRPC presently does not support the use of primitive XDR types as request
or reply arguments to RPC procedures.  A procedure argument must be a named
type corresponding to a struct, enum, or typedef, or must be void.  As here,
if a protocol needs to use a primitive type as a procedure argument, it
must declare and use a typedef for that type.

@until }

We now define the procedure calls to be supported by the server.  Each
procedure can have up to two arguments: one request argument and one reply
argument, in that order.  Unused arguments can be omitted from the procedure
definition or declared to be @c void.  As with @c GetNumColors, a procedure
with a reply argument but no request argument must declare the request argument
to be @c void.  Each procedure is also assigned a procedure number, which is
used on-the-wire to indicate which procedure is being called.

Since these procedures are declared in a @c serverprocs section, they are
procedure calls made from client to server; that is, the client is the sender
and the server is the receiver.  There can also be a @c clientprocs section,
which defines procedure calls initiated by the server and received by the
client.

No two procedures in a protocol can have the same name.  No two procedures
of the same type (@c serverprocs, @c clientprocs, @c servermsgs, or
@c clientmsgs) can have the same procedure number.

@until }

This protocol includes an additional CrayonSelected message, which is not
really a procedure call at all: it is an event notification sent from
client to server, to which the server has no opportunity to reply. (Procedure
calls declared in a @c procs section with a @c void return type, such
as @c ChooseColor above, still involve a reply, since the receiver can
return a success indication or error code.)  Accordingly, procedure
definitions in the @c msgs section take only a request argument.

As above, messages sent from client to server are defined in a @c servermsgs
section, and messages sent by the server are defined in a @c clientmsgs
section.

@section generation Generating the Protocol Interface

This interface definition is converted into C source and header files by
running:

@verbatim
minirpcgen -o example example.mx
@endverbatim

The result is a set of output files:
- example_client.h
- example_server.h
- example_minirpc.c
- example_minirpc.h
- example_xdr.c
- example_xdr.h

The C source files should be compiled into the programs implementing the
client and server (either directly, or indirectly via a library).  The
header files should also be made available to these programs during the
build process.  A client application implementing this example protocol
need only include example_client.h directly; likewise, a server need
only include example_server.h.

Note that the argument given to the @c -o @c minirpcgen option is embedded
not only in the names of the output files, but in the names of the generated
structures and C functions.  For more information on the interface
generated by @c minirpcgen, see @ref example_common, @ref example_client,
and @ref example_server.

@defgroup example_common Common Definitions
@defgroup example_client Client Stubs
@defgroup example_server Server Stubs
@addtogroup example
@}
*/
